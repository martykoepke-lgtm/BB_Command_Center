"""
Report generation service — builds HTML reports from initiative data.

Supports 5 report types:
  1. executive_summary   — high-level overview for leadership
  2. phase_tollgate      — phase gate review document
  3. initiative_closeout — final report when initiative completes
  4. portfolio_review    — cross-initiative portfolio summary
  5. statistical_summary — analysis results and interpretations

HTML output can be converted to PDF via WeasyPrint (when available).

Beacon Phase 3 enhancements:
  - AI narrative integration via ReportAgent
  - Plotly chart embedding as base64 PNG images
  - Graceful degradation when AI/chart deps unavailable
"""

from __future__ import annotations

import base64
import logging
from datetime import datetime, timezone
from uuid import UUID

from sqlalchemy import func, select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from app.models.initiative import Initiative
from app.models.phase import Phase, PhaseArtifact
from app.models.analysis import StatisticalAnalysis
from app.models.supporting import ActionItem, Metric, Report

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# HTML templates (inline — no Jinja dependency needed)
# ---------------------------------------------------------------------------

_BASE_STYLE = """
<style>
  body { font-family: 'Segoe UI', Arial, sans-serif; margin: 40px; color: #1a1a2e; line-height: 1.6; }
  h1 { color: #16213e; border-bottom: 3px solid #0f3460; padding-bottom: 8px; }
  h2 { color: #0f3460; margin-top: 32px; }
  h3 { color: #533483; }
  table { border-collapse: collapse; width: 100%; margin: 16px 0; }
  th { background: #0f3460; color: white; padding: 10px 14px; text-align: left; }
  td { border: 1px solid #ddd; padding: 8px 14px; }
  tr:nth-child(even) { background: #f8f9fa; }
  .metric-card { display: inline-block; background: #f0f4ff; border-radius: 8px; padding: 16px 24px; margin: 8px; text-align: center; }
  .metric-value { font-size: 28px; font-weight: bold; color: #0f3460; }
  .metric-label { font-size: 13px; color: #666; }
  .status-badge { display: inline-block; padding: 2px 10px; border-radius: 12px; font-size: 12px; font-weight: 600; }
  .status-completed { background: #d4edda; color: #155724; }
  .status-active, .status-in_progress { background: #cce5ff; color: #004085; }
  .status-not_started { background: #f8f9fa; color: #666; }
  .status-blocked { background: #f8d7da; color: #721c24; }
  .status-at_risk { background: #fff3cd; color: #856404; }
  .ai-narrative { background: #f8f9ff; border-left: 4px solid #0f3460; padding: 16px 20px; margin: 16px 0; border-radius: 0 8px 8px 0; }
  .ai-narrative h3 { color: #0f3460; margin-top: 0; }
  .chart-container { text-align: center; margin: 20px 0; }
  .chart-container img { max-width: 100%; border: 1px solid #eee; border-radius: 4px; }
  .footer { margin-top: 40px; padding-top: 16px; border-top: 1px solid #ddd; font-size: 12px; color: #999; }
</style>
"""


def _status_badge(status: str) -> str:
    css_class = f"status-{status.replace(' ', '_')}"
    return f'<span class="status-badge {css_class}">{status}</span>'


def _metric_card(label: str, value: str) -> str:
    return f'<div class="metric-card"><div class="metric-value">{value}</div><div class="metric-label">{label}</div></div>'


def _footer() -> str:
    ts = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC")
    return f'<div class="footer">Generated by BB Enabled Command &mdash; {ts}</div>'


def _ai_section(title: str, narrative: str) -> str:
    """Wrap AI narrative in a styled container."""
    return f'<div class="ai-narrative"><h3>{title}</h3>{_markdown_to_html(narrative)}</div>'


def _markdown_to_html(md: str) -> str:
    """Basic markdown to HTML conversion for AI narratives."""
    lines = md.strip().split("\n")
    html_parts: list[str] = []
    in_list = False

    for line in lines:
        stripped = line.strip()
        if not stripped:
            if in_list:
                html_parts.append("</ul>")
                in_list = False
            continue

        if stripped.startswith("### "):
            if in_list:
                html_parts.append("</ul>")
                in_list = False
            html_parts.append(f"<h4>{_inline_bold(stripped[4:])}</h4>")
        elif stripped.startswith("## "):
            if in_list:
                html_parts.append("</ul>")
                in_list = False
            html_parts.append(f"<h3>{_inline_bold(stripped[3:])}</h3>")
        elif stripped.startswith("- ") or stripped.startswith("* "):
            if not in_list:
                html_parts.append("<ul>")
                in_list = True
            html_parts.append(f"<li>{_inline_bold(stripped[2:])}</li>")
        else:
            if in_list:
                html_parts.append("</ul>")
                in_list = False
            html_parts.append(f"<p>{_inline_bold(stripped)}</p>")

    if in_list:
        html_parts.append("</ul>")

    return "\n".join(html_parts)


def _inline_bold(text: str) -> str:
    """Replace **bold** markers with <strong> tags."""
    result = text
    while "**" in result:
        idx = result.index("**")
        rest = result[idx + 2:]
        end_idx = rest.find("**")
        if end_idx == -1:
            break
        before = result[:idx]
        bold = rest[:end_idx]
        after = rest[end_idx + 2:]
        result = f"{before}<strong>{bold}</strong>{after}"
    return result


# ---------------------------------------------------------------------------
# AI Narrative Helper
# ---------------------------------------------------------------------------

async def _get_ai_narrative(
    report_type: str,
    initiative: Initiative | None,
    phase_name: str | None,
    db: AsyncSession,
) -> str | None:
    """
    Generate an AI narrative via the ReportAgent.

    Returns markdown narrative string, or None if AI is unavailable.
    Gracefully degrades: if Anthropic API key is missing or the call fails,
    the report is still generated without the narrative section.
    """
    try:
        from app.agents.report_agent import ReportAgent
        from app.agents.base import AgentContext

        agent = ReportAgent()

        context = AgentContext()
        if initiative:
            context.initiative_id = initiative.id
            context.initiative_title = initiative.title
            context.problem_statement = initiative.problem_statement or ""
            context.desired_outcome = initiative.desired_outcome or ""
            context.methodology = initiative.methodology or ""
            context.current_phase = initiative.current_phase or ""
            context.initiative_status = initiative.status or ""
            context.initiative_priority = initiative.priority or ""

            # Load phases status
            phases_result = await db.execute(
                select(Phase)
                .where(Phase.initiative_id == initiative.id)
                .order_by(Phase.phase_order)
            )
            context.all_phases_status = {
                p.phase_name: p.status
                for p in phases_result.scalars().all()
            }

            # Load metrics
            metrics_result = await db.execute(
                select(Metric).where(Metric.initiative_id == initiative.id)
            )
            context.metrics = [
                {
                    "name": m.name,
                    "unit": m.unit,
                    "baseline_value": float(m.baseline_value) if m.baseline_value else None,
                    "current_value": float(m.current_value) if m.current_value else None,
                    "target_value": float(m.target_value) if m.target_value else None,
                    "target_met": m.target_met,
                }
                for m in metrics_result.scalars().all()
            ]

            # Load completed analyses
            analyses_result = await db.execute(
                select(StatisticalAnalysis)
                .where(
                    StatisticalAnalysis.initiative_id == initiative.id,
                    StatisticalAnalysis.status == "completed",
                )
            )
            context.analysis_results = [
                {
                    "test_type": a.test_type,
                    "test_category": a.test_category,
                    "p_value": a.results.get("p_value") if a.results else None,
                    "ai_interpretation": a.ai_interpretation,
                }
                for a in analyses_result.scalars().all()
            ]

        # Build prompt based on report type
        prompt_map = {
            "executive_summary": f"Generate an executive summary for initiative '{initiative.title if initiative else 'Unknown'}'.",
            "phase_tollgate": f"Generate a phase gate summary for the '{phase_name}' phase of initiative '{initiative.title if initiative else 'Unknown'}'.",
            "initiative_closeout": f"Generate a close-out report narrative for completed initiative '{initiative.title if initiative else 'Unknown'}'.",
            "portfolio_review": "Generate a portfolio executive brief summarizing the current state of all active initiatives.",
            "statistical_summary": f"Generate a statistical analysis translation for the analyses performed on initiative '{initiative.title if initiative else 'Unknown'}'.",
        }

        prompt = prompt_map.get(report_type, f"Generate a {report_type} report.")
        response = await agent.invoke(prompt, context)
        return response.content

    except Exception as e:
        logger.warning("AI narrative generation failed (report will proceed without AI section): %s", e)
        return None


# ---------------------------------------------------------------------------
# Chart Embedding Helper
# ---------------------------------------------------------------------------

def _chart_to_base64(plotly_spec: dict) -> str | None:
    """
    Convert a Plotly chart JSON spec to a base64-encoded PNG image.

    Requires plotly + kaleido. Returns None if conversion fails.
    """
    try:
        import plotly.graph_objects as go
        import plotly.io as pio

        fig = go.Figure(plotly_spec)

        # Use light theme for reports (override dark-mode defaults from Sigma)
        fig.update_layout(
            template="plotly_white",
            paper_bgcolor="white",
            plot_bgcolor="white",
            font_color="#1a1a2e",
            width=700,
            height=400,
        )

        img_bytes = pio.to_image(fig, format="png", engine="kaleido")
        return base64.b64encode(img_bytes).decode("utf-8")
    except Exception as e:
        logger.warning("Chart to image conversion failed: %s", e)
        return None


def _embed_chart_html(chart_b64: str, title: str = "") -> str:
    """Wrap a base64 chart image in an HTML container."""
    caption = f"<p><em>{title}</em></p>" if title else ""
    return f'<div class="chart-container"><img src="data:image/png;base64,{chart_b64}" alt="{title}" />{caption}</div>'


# ---------------------------------------------------------------------------
# Report builders
# ---------------------------------------------------------------------------

async def build_executive_summary(
    initiative_id: UUID,
    db: AsyncSession,
    include_ai: bool = True,
    include_charts: bool = True,
) -> str:
    """Build an executive summary report for a single initiative."""
    result = await db.execute(
        select(Initiative)
        .where(Initiative.id == initiative_id)
        .options(selectinload(Initiative.phases))
    )
    init = result.scalar_one()

    # Metrics
    metrics_result = await db.execute(
        select(Metric).where(Metric.initiative_id == initiative_id)
    )
    metrics = metrics_result.scalars().all()

    # Action items summary
    action_result = await db.execute(
        select(ActionItem.status, func.count(ActionItem.id))
        .where(ActionItem.initiative_id == initiative_id)
        .group_by(ActionItem.status)
    )
    action_counts = {row[0]: row[1] for row in action_result.all()}

    # Build HTML
    phases_html = ""
    for p in sorted(init.phases, key=lambda x: x.phase_order):
        phases_html += f"<tr><td>{p.phase_name.title()}</td><td>{_status_badge(p.status)}</td><td>{float(p.completeness_score):.0f}%</td></tr>"

    metrics_html = ""
    for m in metrics:
        baseline = f"{float(m.baseline_value):.1f}" if m.baseline_value else "\u2014"
        current = f"{float(m.current_value):.1f}" if m.current_value else "\u2014"
        target = f"{float(m.target_value):.1f}" if m.target_value else "\u2014"
        met = "Yes" if m.target_met else ("No" if m.target_met is False else "\u2014")
        metrics_html += f"<tr><td>{m.name}</td><td>{baseline}</td><td>{current}</td><td>{target}</td><td>{met}</td></tr>"

    total_actions = sum(action_counts.values())
    completed_actions = action_counts.get("completed", 0)

    # AI narrative
    ai_html = ""
    if include_ai:
        narrative = await _get_ai_narrative("executive_summary", init, None, db)
        if narrative:
            ai_html = _ai_section("AI Analysis", narrative)

    html = f"""<!DOCTYPE html>
<html><head><meta charset="utf-8"><title>Executive Summary \u2014 {init.title}</title>{_BASE_STYLE}</head>
<body>
<h1>Executive Summary</h1>
<h2>{init.initiative_number}: {init.title}</h2>

<div>
{_metric_card("Status", init.status.title())}
{_metric_card("Phase", init.current_phase.title())}
{_metric_card("Methodology", init.methodology)}
{_metric_card("Priority", init.priority.title())}
</div>

<h2>Problem & Objective</h2>
<p><strong>Problem:</strong> {init.problem_statement}</p>
<p><strong>Desired Outcome:</strong> {init.desired_outcome}</p>
{f'<p><strong>Scope:</strong> {init.scope}</p>' if init.scope else ''}

<h2>Phase Progress</h2>
<table>
<tr><th>Phase</th><th>Status</th><th>Completeness</th></tr>
{phases_html}
</table>

<h2>Key Metrics</h2>
{'<table><tr><th>Metric</th><th>Baseline</th><th>Current</th><th>Target</th><th>Met?</th></tr>' + metrics_html + '</table>' if metrics_html else '<p>No metrics defined yet.</p>'}

<h2>Action Items</h2>
<div>
{_metric_card("Total", str(total_actions))}
{_metric_card("Completed", str(completed_actions))}
{_metric_card("Open", str(total_actions - completed_actions))}
</div>

{f'<h2>Financial Impact</h2><div>{_metric_card("Projected Savings", f"${float(init.projected_savings):,.0f}")}{_metric_card("Actual Savings", f"${float(init.actual_savings):,.0f}") if init.actual_savings else ""}</div>' if init.projected_savings else ''}

{ai_html}

{_footer()}
</body></html>"""

    return html


async def build_phase_tollgate(
    initiative_id: UUID,
    phase_name: str,
    db: AsyncSession,
    include_ai: bool = True,
    include_charts: bool = True,
) -> str:
    """Build a phase gate review document."""
    result = await db.execute(
        select(Initiative).where(Initiative.id == initiative_id)
    )
    init = result.scalar_one()

    phase_result = await db.execute(
        select(Phase).where(Phase.initiative_id == initiative_id, Phase.phase_name == phase_name)
    )
    phase = phase_result.scalar_one()

    # Artifacts for this phase
    artifacts_result = await db.execute(
        select(PhaseArtifact).where(PhaseArtifact.phase_id == phase.id)
    )
    artifacts = artifacts_result.scalars().all()

    # Actions for this phase
    actions_result = await db.execute(
        select(ActionItem).where(ActionItem.phase_id == phase.id)
    )
    actions = actions_result.scalars().all()

    artifacts_html = ""
    for a in artifacts:
        artifacts_html += f"<tr><td>{a.title}</td><td>{a.artifact_type}</td><td>{_status_badge(a.status)}</td></tr>"

    actions_html = ""
    for a in actions:
        owner = a.owner_name or "Unassigned"
        due = a.due_date.strftime("%Y-%m-%d") if a.due_date else "\u2014"
        actions_html += f"<tr><td>{a.title}</td><td>{owner}</td><td>{_status_badge(a.status)}</td><td>{due}</td></tr>"

    # AI assessment
    ai_html = ""
    if include_ai:
        narrative = await _get_ai_narrative("phase_tollgate", init, phase_name, db)
        if narrative:
            ai_html = _ai_section("AI Gate Assessment", narrative)

    html = f"""<!DOCTYPE html>
<html><head><meta charset="utf-8"><title>Tollgate Review \u2014 {phase_name.title()} Phase</title>{_BASE_STYLE}</head>
<body>
<h1>Phase Tollgate Review</h1>
<h2>{init.initiative_number}: {init.title} \u2014 {phase_name.title()} Phase</h2>

<div>
{_metric_card("Phase Status", phase.status.replace("_", " ").title())}
{_metric_card("Completeness", f"{float(phase.completeness_score):.0f}%")}
{_metric_card("Gate Approved", "Yes" if phase.gate_approved else "No")}
</div>

{f'<p><strong>Gate Notes:</strong> {phase.gate_notes}</p>' if phase.gate_notes else ''}
{f'<p><strong>AI Summary:</strong> {phase.ai_summary}</p>' if phase.ai_summary else ''}

<h2>Deliverables</h2>
{'<table><tr><th>Title</th><th>Type</th><th>Status</th></tr>' + artifacts_html + '</table>' if artifacts_html else '<p>No artifacts submitted.</p>'}

<h2>Action Items</h2>
{'<table><tr><th>Title</th><th>Owner</th><th>Status</th><th>Due</th></tr>' + actions_html + '</table>' if actions_html else '<p>No action items for this phase.</p>'}

{ai_html}

{_footer()}
</body></html>"""

    return html


async def build_initiative_closeout(
    initiative_id: UUID,
    db: AsyncSession,
    include_ai: bool = True,
    include_charts: bool = True,
) -> str:
    """Build a closeout report for a completed initiative."""
    result = await db.execute(
        select(Initiative)
        .where(Initiative.id == initiative_id)
        .options(selectinload(Initiative.phases))
    )
    init = result.scalar_one()

    metrics_result = await db.execute(
        select(Metric).where(Metric.initiative_id == initiative_id)
    )
    metrics = metrics_result.scalars().all()

    analyses_result = await db.execute(
        select(StatisticalAnalysis)
        .where(StatisticalAnalysis.initiative_id == initiative_id)
        .where(StatisticalAnalysis.status == "completed")
    )
    analyses = analyses_result.scalars().all()

    # Phase timeline
    timeline_html = ""
    for p in sorted(init.phases, key=lambda x: x.phase_order):
        started = p.started_at.strftime("%Y-%m-%d") if p.started_at else "\u2014"
        completed = p.completed_at.strftime("%Y-%m-%d") if p.completed_at else "\u2014"
        timeline_html += f"<tr><td>{p.phase_name.title()}</td><td>{started}</td><td>{completed}</td><td>{_status_badge(p.status)}</td></tr>"

    # Results
    metrics_html = ""
    for m in metrics:
        baseline = f"{float(m.baseline_value):.1f}" if m.baseline_value else "\u2014"
        final = f"{float(m.current_value):.1f}" if m.current_value else "\u2014"
        target = f"{float(m.target_value):.1f}" if m.target_value else "\u2014"
        met = "Yes" if m.target_met else "No" if m.target_met is False else "\u2014"
        metrics_html += f"<tr><td>{m.name}</td><td>{baseline}</td><td>{final}</td><td>{target}</td><td>{met}</td></tr>"

    analyses_html = ""
    for a in analyses:
        p_val = a.results.get("p_value", "\u2014") if a.results else "\u2014"
        analyses_html += f"<tr><td>{a.test_type}</td><td>{a.test_category}</td><td>{p_val}</td></tr>"

    # AI narrative
    ai_html = ""
    if include_ai:
        narrative = await _get_ai_narrative("initiative_closeout", init, None, db)
        if narrative:
            ai_html = _ai_section("AI Project Narrative", narrative)

    html = f"""<!DOCTYPE html>
<html><head><meta charset="utf-8"><title>Closeout \u2014 {init.title}</title>{_BASE_STYLE}</head>
<body>
<h1>Initiative Closeout Report</h1>
<h2>{init.initiative_number}: {init.title}</h2>

<div>
{_metric_card("Methodology", init.methodology)}
{_metric_card("Duration", f"{(init.actual_completion - init.start_date).days} days" if init.actual_completion and init.start_date else "\u2014")}
{_metric_card("Status", init.status.title())}
</div>

<h2>Problem & Outcome</h2>
<p><strong>Problem:</strong> {init.problem_statement}</p>
<p><strong>Desired Outcome:</strong> {init.desired_outcome}</p>
{f'<p><strong>Actual Impact:</strong> {init.actual_impact}</p>' if init.actual_impact else ''}

<h2>Phase Timeline</h2>
<table>
<tr><th>Phase</th><th>Started</th><th>Completed</th><th>Status</th></tr>
{timeline_html}
</table>

<h2>Results</h2>
{'<table><tr><th>Metric</th><th>Baseline</th><th>Final</th><th>Target</th><th>Met?</th></tr>' + metrics_html + '</table>' if metrics_html else '<p>No metrics recorded.</p>'}

{f'<h2>Financial Impact</h2><div>{_metric_card("Projected", f"${float(init.projected_savings):,.0f}")}{_metric_card("Actual", f"${float(init.actual_savings):,.0f}") if init.actual_savings else ""}</div>' if init.projected_savings else ''}

{'<h2>Statistical Analyses</h2><table><tr><th>Test</th><th>Category</th><th>p-value</th></tr>' + analyses_html + '</table>' if analyses_html else ''}

{ai_html}

{_footer()}
</body></html>"""

    return html


async def build_portfolio_review(
    db: AsyncSession,
    include_ai: bool = True,
    include_charts: bool = True,
) -> str:
    """Build a portfolio-wide review report (not initiative-specific)."""
    # Status counts
    status_result = await db.execute(
        select(Initiative.status, func.count(Initiative.id)).group_by(Initiative.status)
    )
    status_counts = {row[0]: row[1] for row in status_result.all()}
    total = sum(status_counts.values())

    # Methodology counts
    method_result = await db.execute(
        select(Initiative.methodology, func.count(Initiative.id)).group_by(Initiative.methodology)
    )
    method_counts = {row[0]: row[1] for row in method_result.all()}

    # Savings
    savings_result = await db.execute(
        select(
            func.coalesce(func.sum(Initiative.projected_savings), 0),
            func.coalesce(func.sum(Initiative.actual_savings), 0),
        )
    )
    projected, actual = savings_result.one()

    # Active initiatives detail
    active_result = await db.execute(
        select(Initiative)
        .where(Initiative.status == "active")
        .order_by(Initiative.priority.desc(), Initiative.created_at.asc())
    )
    active = active_result.scalars().all()

    active_html = ""
    for i in active:
        active_html += f"<tr><td>{i.initiative_number}</td><td>{i.title}</td><td>{i.methodology}</td><td>{i.current_phase.title()}</td><td>{i.priority.title()}</td></tr>"

    status_html = ""
    for s, c in sorted(status_counts.items()):
        pct = round(c / total * 100) if total else 0
        status_html += f"<tr><td>{s.title()}</td><td>{c}</td><td>{pct}%</td></tr>"

    # Methodology breakdown
    method_html = ""
    for m, c in sorted(method_counts.items()):
        method_html += f"<tr><td>{m}</td><td>{c}</td></tr>"

    # AI narrative
    ai_html = ""
    if include_ai:
        narrative = await _get_ai_narrative("portfolio_review", None, None, db)
        if narrative:
            ai_html = _ai_section("Portfolio Health Assessment", narrative)

    html = f"""<!DOCTYPE html>
<html><head><meta charset="utf-8"><title>Portfolio Review</title>{_BASE_STYLE}</head>
<body>
<h1>Portfolio Review</h1>

<div>
{_metric_card("Total Initiatives", str(total))}
{_metric_card("Active", str(status_counts.get("active", 0)))}
{_metric_card("Completed", str(status_counts.get("completed", 0)))}
{_metric_card("Blocked", str(status_counts.get("blocked", 0)))}
{_metric_card("Projected Savings", f"${float(projected):,.0f}")}
{_metric_card("Actual Savings", f"${float(actual):,.0f}")}
</div>

<h2>Status Distribution</h2>
<table>
<tr><th>Status</th><th>Count</th><th>%</th></tr>
{status_html}
</table>

<h2>Methodology Breakdown</h2>
{'<table><tr><th>Methodology</th><th>Count</th></tr>' + method_html + '</table>' if method_html else ''}

<h2>Active Initiatives</h2>
{'<table><tr><th>#</th><th>Title</th><th>Methodology</th><th>Phase</th><th>Priority</th></tr>' + active_html + '</table>' if active_html else '<p>No active initiatives.</p>'}

{ai_html}

{_footer()}
</body></html>"""

    return html


async def build_statistical_summary(
    initiative_id: UUID,
    db: AsyncSession,
    include_ai: bool = True,
    include_charts: bool = True,
) -> str:
    """Build a summary of all statistical analyses for an initiative."""
    result = await db.execute(
        select(Initiative).where(Initiative.id == initiative_id)
    )
    init = result.scalar_one()

    analyses_result = await db.execute(
        select(StatisticalAnalysis)
        .where(StatisticalAnalysis.initiative_id == initiative_id)
        .order_by(StatisticalAnalysis.created_at.asc())
    )
    analyses = analyses_result.scalars().all()

    rows_html = ""
    details_html = ""
    for i, a in enumerate(analyses, 1):
        p_val = a.results.get("p_value", "\u2014") if a.results else "\u2014"
        stat = a.results.get("statistic", "\u2014") if a.results else "\u2014"
        rows_html += f"<tr><td>{i}</td><td>{a.test_type}</td><td>{a.test_category}</td><td>{stat}</td><td>{p_val}</td><td>{_status_badge(a.status)}</td></tr>"

        if a.ai_interpretation:
            details_html += f"<h3>Analysis {i}: {a.test_type}</h3><p>{a.ai_interpretation}</p>"
            if a.ai_next_steps:
                details_html += f"<p><strong>Next Steps:</strong> {a.ai_next_steps}</p>"

        # Embed charts as static images
        if include_charts and a.charts:
            charts_data = a.charts if isinstance(a.charts, list) else [a.charts]
            for chart_spec in charts_data:
                if isinstance(chart_spec, dict):
                    chart_b64 = _chart_to_base64(chart_spec)
                    if chart_b64:
                        chart_title = chart_spec.get("title", f"Analysis {i} Chart")
                        details_html += _embed_chart_html(chart_b64, chart_title)

    # AI overall narrative
    ai_html = ""
    if include_ai:
        narrative = await _get_ai_narrative("statistical_summary", init, None, db)
        if narrative:
            ai_html = _ai_section("AI Statistical Summary", narrative)

    html = f"""<!DOCTYPE html>
<html><head><meta charset="utf-8"><title>Statistical Summary \u2014 {init.title}</title>{_BASE_STYLE}</head>
<body>
<h1>Statistical Analysis Summary</h1>
<h2>{init.initiative_number}: {init.title}</h2>

{_metric_card("Total Analyses", str(len(analyses)))}
{_metric_card("Completed", str(sum(1 for a in analyses if a.status == "completed")))}
{_metric_card("Failed", str(sum(1 for a in analyses if a.status == "failed")))}

<h2>Analysis Results</h2>
{'<table><tr><th>#</th><th>Test</th><th>Category</th><th>Statistic</th><th>p-value</th><th>Status</th></tr>' + rows_html + '</table>' if rows_html else '<p>No analyses run yet.</p>'}

{'<h2>Detailed Results & Charts</h2>' + details_html if details_html else ''}

{ai_html}

{_footer()}
</body></html>"""

    return html


# ---------------------------------------------------------------------------
# Dispatcher
# ---------------------------------------------------------------------------

REPORT_BUILDERS = {
    "executive_summary": build_executive_summary,
    "phase_tollgate": build_phase_tollgate,
    "initiative_closeout": build_initiative_closeout,
    "portfolio_review": build_portfolio_review,
    "statistical_summary": build_statistical_summary,
}


REPORT_TITLES = {
    "executive_summary": "Executive Summary",
    "phase_tollgate": "Phase Tollgate Review",
    "initiative_closeout": "Initiative Closeout Report",
    "portfolio_review": "Portfolio Review",
    "statistical_summary": "Statistical Analysis Summary",
}


async def generate_report(
    report_type: str,
    initiative_id: UUID | None,
    phase_name: str | None,
    db: AsyncSession,
    include_ai: bool = True,
    include_charts: bool = True,
) -> str:
    """
    Generate an HTML report.

    Args:
        report_type: One of the REPORT_BUILDERS keys
        initiative_id: Required for all types except portfolio_review
        phase_name: Required for phase_tollgate
        db: Database session
        include_ai: Whether to include AI-generated narrative sections
        include_charts: Whether to embed Plotly charts as images

    Returns the raw HTML string.
    """
    builder = REPORT_BUILDERS.get(report_type)
    if builder is None:
        raise ValueError(f"Unknown report type: {report_type}. Available: {list(REPORT_BUILDERS.keys())}")

    if report_type == "portfolio_review":
        return await builder(db, include_ai=include_ai, include_charts=include_charts)
    elif report_type == "phase_tollgate":
        if not initiative_id or not phase_name:
            raise ValueError("phase_tollgate requires initiative_id and phase_name")
        return await builder(initiative_id, phase_name, db, include_ai=include_ai, include_charts=include_charts)
    else:
        if not initiative_id:
            raise ValueError(f"{report_type} requires initiative_id")
        return await builder(initiative_id, db, include_ai=include_ai, include_charts=include_charts)
